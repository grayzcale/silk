[{"title":"Accessing SILK","type":0,"sectionRef":"#","url":"/silk/docs/getting_started/accessing_silk","content":"","keywords":""},{"title":"Using Scripts​","type":1,"pageTitle":"Accessing SILK","url":"/silk/docs/getting_started/accessing_silk#using-scripts","content":"To start using SILK in scripts, the script must first yield until the server reaches the initialized state. To do this, execute the Silk.Wait method after retrieving Silk normally. This will ensure that the script yields until the server is in a ready state. Sample server script:​ -- || script.server.lua || -- Retrieve the Silk class using Silk.Wait local silk = require(game:GetService('ReplicatedStorage'):WaitForChild('silk')):Wait() print('Server is ready!')  The same principle is also applied to client scripts. When using the Silk.Wait method, LocalScripts will yield until the client reaches a ready state. "},{"title":"About","type":0,"sectionRef":"#","url":"/silk/docs/intro","content":"About SILK is an intricate game development framework designed to streamline the overall process of game development. With its simple yet effective stage-execution model, the SILK lifecycle enables developers to effectively manage large pieces of code with ease, keeping everything well-organized. This framework is highly versatile and flexible—adaptable to all development workflows and preferences. With the introduction of packages, developers are given the ability to develop code in a non-destructive manner, quickly producing more reliable and predictable results. The framework also includes pre-written packages involving the standard core functionalities for any typical project. Get started with SILK by visiting Getting Started or check out the other links below. API DocumentationThe SILK Lifecycle","keywords":""},{"title":"Math","type":0,"sectionRef":"#","url":"/silk/api/Math","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Math","url":"/silk/api/Math#functions","content":" "},{"title":"isInRange​","type":1,"pageTitle":"Math","url":"/silk/api/Math#isInRange","content":"&lt;/&gt; Math.isInRange( value: number, min: number, max: number ) → boolean Returns a boolean true if value is within bounds (inclusive).  "},{"title":"mapRange​","type":1,"pageTitle":"Math","url":"/silk/api/Math#mapRange","content":"&lt;/&gt; Math.mapRange( inputBounds: { inputMin: number, inputMax: number }, outputBounds: { outputMin: number, outputMax: number } ) → (x: number) → number Returns a function with an input parameter, which when executed, returns an output for the given bounds. Math.mapRange({ 0, 1 }, { 0, 100 })(0.5) -- 50  "},{"title":"Ray","type":0,"sectionRef":"#","url":"/silk/api/Ray","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Ray","url":"/silk/api/Ray#types","content":" "},{"title":"Ray​","type":1,"pageTitle":"Ray","url":"/silk/api/Ray#Ray","content":"&lt;/&gt; type Ray = Ray To set any of the RaycastParams, access it directly from the object and set the value. local ray = Ray.new(...) -- Ignore Terrain water ray.IgnoreWater = true  "},{"title":"Functions​","type":1,"pageTitle":"Ray","url":"/silk/api/Ray#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Ray","url":"/silk/api/Ray#new","content":"instantiater &lt;/&gt; Ray.new( origin: Vector3 , direction: Vector3 ) → Ray Create a new Ray object using origin and direction.  "},{"title":"Cast​","type":1,"pageTitle":"Ray","url":"/silk/api/Ray#Cast","content":"&lt;/&gt; Ray:Cast() → RaycastResult Equivalent to workspace:Raycast().  "},{"title":"CastExclude​","type":1,"pageTitle":"Ray","url":"/silk/api/Ray#CastExclude","content":"&lt;/&gt; Ray:CastExclude(exclude: {Instance }) → RaycastResult Sets the filter type to Exclude and applies the filter, then executes Ray.Cast.  "},{"title":"Visualize​","type":1,"pageTitle":"Ray","url":"/silk/api/Ray#Visualize","content":"&lt;/&gt; Ray:Visualize(args: { color: Color3? , decay: number? }) → () Creates a new part to visualize the ray. By default, color is a random Color3 value and decay is 7 seconds. "},{"title":"The SILK Lifecycle","type":0,"sectionRef":"#","url":"/silk/docs/lifecycle","content":"The SILK Lifecycle The SILK lifecycle is designed to simplify the overall control of package usage and stage execution. The initialization phase is initiated by a single bootstrapper script that is responsible for supplying the framework with any specific dependencies. Any script that attempts to retrieve and access the primary singleton class using Silk.Wait during the uninitialized phase will yield until the initialization is completed. The server initialization phase takes precedence over the client initialization phase, i.e. if the client requests initialization data before the server reaches the initialized state, the client must yield until the server is ready to provide the data. Configuration will only be provided once through the server intializer script. When the client requests data for initialization, it aims to make a seamless local copy of the initialized singleton class that exists on the server. In this way, when the data is recieved by the client, some information may be lost since it may not be visible to the client. Just like with normal server-sided scripts, client scripts begin execution immediately after the client reaches the initialized state. Additionally, any communication between the client and server, including during the client initialization phase, only takes place with the server in its intialized state. This approach gurantees that the server is always in a ready state whenever the client communicates. Diagram of the SILK lifecycle:​","keywords":""},{"title":"Initialization Phase","type":0,"sectionRef":"#","url":"/silk/docs/getting_started/initialization_phase","content":"","keywords":""},{"title":"Initializer Script​","type":1,"pageTitle":"Initialization Phase","url":"/silk/docs/getting_started/initialization_phase#initializer-script","content":"To begin, start by creating a single script on the server. Require the Silk object normally as you would with any typical ModuleScript and type in any necessary configurations. The general purpose of this script is to end the initialization phase and allow other scripts to begin execution. Although the contents of this script will vary with every project, a typical initializer script may look something like the following. Sample initializer script:​ -- || initializer.server.lua || -- Path to the SILK ModuleScript local silk = require(game:GetService('ReplicatedStorage'):WaitForChild('silk')) -- Adding in containers silk.AppendPackage{ silk.ReplicatedStorage:WaitForChild('Assets'), silk.ServerStorage:WaitForChild('PrivateAssets'), } -- Adding in classes silk.AppendClasses{ silk.ReplicatedStorage:WaitForChild('Classes') } -- Adding in packages silk.AppendPackage{ silk.getScript():WaitForChild('essentials'), silk.ReplicatedStorage:WaitForChild('Packages'), } -- Initialization of the Network package and adding in communicators silk.Packages.Network:AppendCommunicators{ silk.ServerStorage:WaitForChild('Communicators') } -- Initialization of other singleton packages silk:InitPackage('DataStorePackage') -- Complete initialization silk:Weave()   "},{"title":"Client Initializer Script​","type":1,"pageTitle":"Initialization Phase","url":"/silk/docs/getting_started/initialization_phase#client-initializer-script","content":"Unlike the server initializer script, providing configuration data to the client is not necessary. When a new client joins the server, the script automatically requests intialization data from the server and makes a seamless copy of singleteon class from the server. As seen above, some data like folders in the ServerStorage will not be replicated over to the client since they are hidden. This script should generally be used to load in the necessary assets for the client and to initialize any client-sided components. Sample client initializer script:​ -- || initializer.client.lua || -- Path to the SILK ModuleScript local silk = require(game:GetService('ReplicatedStorage'):WaitForChild('silk')) -- Complete client-sided initialization silk:Weave()  "},{"title":"Network","type":0,"sectionRef":"#","url":"/silk/api/Network","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Network","url":"/silk/api/Network#functions","content":" "},{"title":"AppendCommunicators​","type":1,"pageTitle":"Network","url":"/silk/api/Network#AppendCommunicators","content":"&lt;/&gt; Network:AppendCommunicators(commDirectories: {Folder }) → () Use this method to add communicators during the initialization phase.  "},{"title":"GetCommunicator​","type":1,"pageTitle":"Network","url":"/silk/api/Network#GetCommunicator","content":"&lt;/&gt; Network:GetCommunicator(...: { communicator: string, remote: string }) → NetworkRemote Using the communicator and remote name, you can obtain access to the remote. If called by the server, a RemoteEvent or RemoteFunction is returned directly. For clients however, instead of returning the remote Instance directly, only the remote methods are exposed through a table. Communicators can also be obtained by calling the Network package directly with the same parameters. Getting a communicator by calling the package local remote = network{ &lt;Communicator&gt;, &lt;Remote&gt; }  "},{"title":"Package","type":0,"sectionRef":"#","url":"/silk/api/Package","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Package","url":"/silk/api/Package#properties","content":" "},{"title":"__domain​","type":1,"pageTitle":"Package","url":"/silk/api/Package#__domain","content":"&lt;/&gt; Package.__domain: string An optional meta attribute used to place domain restriction on a package. The default behaviour is shared. Change the attribute to server or client restrict access.  "},{"title":"__singleton​","type":1,"pageTitle":"Package","url":"/silk/api/Package#__singleton","content":"&lt;/&gt; Package.__singleton: boolean An optional meta attribute that can be included in any package. If set to true, a cached reference to the package is returned whenever the package is referenced. info If Package.__initialize is also provided, the return value recieved after calling this method is cached instead. "},{"title":"Functions​","type":1,"pageTitle":"Package","url":"/silk/api/Package#functions","content":" "},{"title":"__initialize​","type":1,"pageTitle":"Package","url":"/silk/api/Package#__initialize","content":"&lt;/&gt; Package.__initialize(silk: Silk) → any An optional meta function that can be included in any package. This method should typically be used when further initialization (using Silk) is required before returning the package. "},{"title":"Setting Up","type":0,"sectionRef":"#","url":"/silk/docs/getting_started/setting_up","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Setting Up","url":"/silk/docs/getting_started/setting_up#installation","content":"Go to GitHub Releases and download the attached .rbxm file from the latest release. Alternatively, download the source code and move the src folder to anywhere inside your project then rename it to &quot;silk.&quot;  "},{"title":"Project Structure​","type":1,"pageTitle":"Setting Up","url":"/silk/docs/getting_started/setting_up#project-structure","content":"A project can typically be structured in any way preferred by the developer. The following minimalistic structure shows an example of what an ideal project might look like. Ideal project structure:​ Project │ ├─ ServerScriptService │ ├─ initializer.server.lua │ └─ script.server.lua │ ├─ ReplicatedStorage │ └─ silk │ └─ ... │ └─ StarterPlayer └─ StarterPlayerScripts ├─ initializer.client.lua └─ script.client.lua  "},{"title":"Writing Packages","type":0,"sectionRef":"#","url":"/silk/docs/getting_started/writing_packages","content":"","keywords":""},{"title":"Writing A Data Store Package​","type":1,"pageTitle":"Writing Packages","url":"/silk/docs/getting_started/writing_packages#writing-a-data-store-package","content":"This section guides you through an example of writing a minimalistic data store package to save, load, and increment user data. Structuring the package as a singleton will make sure that it gets intialized once whenever it is accessed. To declare a singleton package, set the meta attribute __singleton of the table to true. Declaring a singleton package:​ -- Declare package to be a singleton local datastore = { __singleton = true } return datastore  Before writing the necessary functions to save and load data, the package requires access to the Silk object. Using the __initialize meta method, you can obtain access to Silk and store it inside the metatable. Converting the package to a metatable:​ local datastore = { __singleton = true } datastore.__index = datastore -- Gain access to the singleton class using the __initialize meta method function datastore.__initialize(silk) -- Store Silk inside metatable datastore.silk = silk local self = setmetatable({ _datastore = datastore.silk.DataStoreService:GetDataStore('DATA'), }, datastore) return self end return datastore  You can then begin writing in the various methods to load, save, and increment data... Complete package script:​ caution This is a minimal example that saves and loads data. It does not handle potential errors or edge cases such as when players join the game before the PlayerAdded connection is created. -- || DataStore.lua || local datastore = { __singleton = true } datastore.__index = datastore -- Write private function to return client key local function getId(client) return `userdata_{client.UserId}` end function datastore.__initialize(silk) datastore.silk = silk local self = setmetatable({ _datastore = datastore.silk.DataStoreService:GetDataStore('DATA'), }, datastore) -- Load data when a new player joins self.silk.Players.PlayerAdded:Connect(function(client) self:LoadData(client) -- Wait 3 seconds and increment coins by 100 task.delay(3, self.AddCoins, self, client, 100) end) -- Save data when the player leaves self.silk.Players.PlayerRemoving:Connect(function(client) self:SaveData(client) end) return self end -- Primary data loading method function datastore:LoadData(client) -- Get data or set an initial value if it doesn't exist local data = self._datastore:GetAsync(getId(client)) data = data or {coins = 100} -- Create leaderstats to display coins local leaderstats = self.silk.new('Folder', client).Name('leaderstats')() self.silk.new('IntValue', leaderstats).Name('Coins').Value(data.coins) print(`Loaded data for {client.Name}!`) end -- Primary method to save data function datastore:SaveData(client) -- Read data from leaderstats local data = {coins = client.leaderstats.Coins.Value} -- Save data self._datastore:SetAsync(getId(client), data) print(`Saved data for {client.Name}!`) end -- Increments coins in the leaderstats function datastore:AddCoins(client, amount) client.leaderstats.Coins.Value += amount end return datastore   "},{"title":"Using The Package​","type":1,"pageTitle":"Writing Packages","url":"/silk/docs/getting_started/writing_packages#using-the-package","content":"To use the package, first create a Folder somewhere in your project and move the package script inside it. Append the directory of the folder inside your initializer script using Silk.AppendPackages and initialize the package using Silk.InitPackage, which will then execute the __initialize meta method. Initializing the package:​ -- || initializer.server.lua || local silk = require(game:GetService('ReplicatedStorage'):WaitForChild('silk')) silk:AppendPackages{ -- This folder contains the package 'DataStore' silk.ServerStorage:WaitForChild('PrivatePackages'), } -- Initialize the package silk:InitPackage('DataStore') silk:Weave()  "},{"title":"Client","type":0,"sectionRef":"#","url":"/silk/api/Client","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Client","url":"/silk/api/Client#properties","content":" "},{"title":"Client​","type":1,"pageTitle":"Client","url":"/silk/api/Client#Client","content":"&lt;/&gt; Client.Client: Player  Returns the Player object for the client. Equivalent to game.Players.LocalPlayer.  "},{"title":"PlayerGui​","type":1,"pageTitle":"Client","url":"/silk/api/Client#PlayerGui","content":"&lt;/&gt; Client.PlayerGui: PlayerGui  Returns the PlayerGui of the client. "},{"title":"Functions​","type":1,"pageTitle":"Client","url":"/silk/api/Client#functions","content":" "},{"title":"BindMouseLock​","type":1,"pageTitle":"Client","url":"/silk/api/Client#BindMouseLock","content":"&lt;/&gt; Client:BindMouseLock(key: string) → () Change the MouseLock keybind for the client. A complete list of all the keys can be found here.  "},{"title":"Character​","type":1,"pageTitle":"Client","url":"/silk/api/Client#Character","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Client:Character(waitFor: boolean) → Model, Humanoid, Part | nil Performs appropriate checks to see if the client character exists and if it does, returns the character Model, Humanoid, and the HumanoidRootPart. Returns nil if the character doesn't exist and waitFor isn't set to true. "},{"title":"Silk","type":0,"sectionRef":"#","url":"/silk/api/Silk","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#types","content":" "},{"title":"Container​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#Container","content":"&lt;/&gt; type Container = Folder  A Container is a Folder that contains a specific collection of objects as its children. Containers can be added to the framework using Silk.AppendContainers during the initializer phase. Adding containers: -- || initializer.server.lua || silk:AppendContainers{ -- Supply a folder 'Assets' as a container with the name 'Asset' Asset = silk.ReplicatedStorage:WaitForChild('Assets'), } You can access a container by executing Silk.Get&lt;Container&gt;(object: string) -&gt; Instance as a method of the framework. See below for more details. Accessing objects inside containers: -- A container named 'Asset' local asset = silk:GetAsset('Model'):Clone() Container methods: Silk.AppendContainers Silk.GetContainer  "},{"title":"Service​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#Service","content":"&lt;/&gt; type Service = Instance  Roblox service as an Instance. Getting a service: -- Directly access any service from Silk local replicatedStorage = silk.ReplicatedStorage Limitation You may recieve an error while trying to get some services. This is because the service may not exist in the current list of services. To fix this, open the ModuleScript services and manually type it in. "},{"title":"Functions​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#functions","content":" "},{"title":"getScript​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#getScript","content":"utility &lt;/&gt; Silk.getScript() → ModuleScript  This utility function returns a reference to the main SILK ModuleScript. You can use it to easily access the contents of the script. For instance, when adding in essential packages to the framework. Adding essential packages: -- || initializer.server.lua || silk:AppendPackages{ -- Directly access the children of the ModuleScript silk.getScript():WaitForChild('essentials'), }   "},{"title":"new​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#new","content":"utility &lt;/&gt; Silk.new( object: string | Instance , parent: Instance? ) → SilkObject Built-in implementation of a method-chainable object instantiator. Call itself at the end of the chain to return Instance. Creating a new part: local part = silk.new('Part', workspace).Name('NewPart').Anchored(true)()   "},{"title":"waitFor​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#waitFor","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields utility &lt;/&gt; Silk.waitFor( objects: { Instance , ...string }, timeout: number? ) → Instance  A custom wrapper function for the Instance.WaitForChild method. Use this utility function to simplify your code and avoid redundant chains of consequtive WaitForChild calls. Usage example: -- Long, consequtive calls of .WaitForChild... A:WaitForChild('B'):WaitForChild('C'):WaitForChild('D') -- ...can be simplied to this silk.waitFor{ A, 'B', 'C', 'D' }   "},{"title":"FireAllClients​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#FireAllClients","content":"network &lt;/&gt; Silk:FireAllClients( action: string, ...: any ) → ()   "},{"title":"FireClient​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#FireClient","content":"network &lt;/&gt; Silk:FireClient( client: Player , action: string, ...: any ) → ()   "},{"title":"FireServer​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#FireServer","content":"network &lt;/&gt; Silk:FireServer( action: string, ...: any ) → ()   "},{"title":"InvokeServer​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#InvokeServer","content":"network &lt;/&gt; Silk:InvokeServer( action: string, ...: any ) → ...any   "},{"title":"RegisterAction​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#RegisterAction","content":"network &lt;/&gt; Silk:RegisterAction( action: string, callback: (...any) → ...any ) → () Register an action to the server to quickly handle commuincation between server and client. tip Use this method in packages that require server and client communication for initialization.  "},{"title":"UnregisterAction​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#UnregisterAction","content":"network &lt;/&gt; Silk:UnregisterAction(action: string) → () Remove an existing action from the server.  "},{"title":"AppendClasses​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#AppendClasses","content":"initializer &lt;/&gt; Silk:AppendClasses(classdirectories: {Folder }) → () Use this method to supply multiple class directories to the framework.  "},{"title":"AppendContainers​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#AppendContainers","content":"initializer &lt;/&gt; Silk:AppendContainers(containerDirectories: {[string]: Folder }) → () Use this method to supply multiple container directories to the framework.  "},{"title":"AppendPackages​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#AppendPackages","content":"initializer &lt;/&gt; Silk:AppendPackages(packageDirectories: {Folder }) → () Use this method to supply multiple package directories to the framework.  "},{"title":"Declare​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#Declare","content":"&lt;/&gt; Silk:Declare( callback: ( msg: string, ...any ) → ..any, msg: string ) → () Used internally to indicate potential any errors and warnings to output.  "},{"title":"GetContainer​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#GetContainer","content":"&lt;/&gt; Silk:GetContainer(container: string) → Folder  Returns the Folder associated with the container.  "},{"title":"GetService​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#GetService","content":"&lt;/&gt; Silk:GetService(service: string) → Instance  Gets a Roblox service as an Instance and caches it internally. This method is called internally whenever a service is attempted to be retrieved via silk.&lt;Service&gt;.  "},{"title":"InitClass​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#InitClass","content":"&lt;/&gt; Silk:InitClass(class: string) → ...any This method is called internally whenever a class is referenced silk.Classes.&lt;Class&gt;. This method can be used directly to intialize any class if needed.  "},{"title":"InitPackage​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#InitPackage","content":"&lt;/&gt; Silk:InitPackage(package: Package) → ...any This method is called internally whenever a package is referenced silk.Packages.&lt;Package&gt;. tip Use this method to intialize any singleton packages during the initializer phase.  "},{"title":"IsServer​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#IsServer","content":"&lt;/&gt; Silk:IsServer() → boolean Returns true if the current execution is taking place on the server.  "},{"title":"Wait​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Silk:Wait() → Silk Yields until the initialization phase is completed, i.e. Silk should be accessed this way for all scripts except the initializer scripts. See Silk.Weave for more information.  "},{"title":"Weave​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#Weave","content":"&lt;/&gt; Silk:Weave() → () Marks the end of the initialization phase and resumes execution for all scripts yielding with Silk.Wait. Use this method inside of a single initializer script and call it at the end of the phase when all the initializations are complete. See below for more details. Sample initializer script -- || initializer.server.lua || local silk = require(...) -- Perform initializations silk:AppendPackages{ ... } silk:AppendContainers{ ... } silk:AppendClasses{ ... } silk.Packages.Network:AppendCommunicators{ ... } -- Call Silk.Weave to end the initialization phase silk:Weave()  "}]