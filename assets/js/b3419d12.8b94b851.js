"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[756],{9228:e=>{e.exports=JSON.parse('{"functions":[{"name":"getScript","desc":"\\t\\nThis utility function returns a reference to the main SILK [ModuleScript]. You can use it to easily access the contents of the script. For instance, when adding in *essential* packages to the framework.\\n\\n##### Adding essential packages:\\n```lua\\n-- || initializer.server.lua ||\\n\\nsilk:AppendPackages{\\n\\n\\t-- Directly access children of the Silk script\\n\\tsilk.getScript():WaitForChild(\'essentials\'),\\n}\\n```","params":[],"returns":[{"desc":"","lua_type":"ModuleScript\\r\\n"}],"function_type":"static","tags":["utility"],"source":{"line":118,"path":"src/init.lua"}},{"name":"new","desc":"Built-in implementation of a method-chainable object instantiator. Call itself at the end of the chain to return [Instance].\\n\\n:::danger important\\nDo not forget to call itself after instantiation to return [Instance] (if needed).\\n:::\\n\\n##### Creating a new object:\\n```lua\\nlocal part = silk.new(\'Part\', workspace)\\n\\t.Name(\'NewPart\')\\n\\t.Anchored(true)()\\n```","params":[{"name":"object","desc":"","lua_type":"string | Instance"},{"name":"parent","desc":"","lua_type":"Instance?"}],"returns":[{"desc":"","lua_type":"self\\r\\n"}],"function_type":"static","tags":["utility"],"source":{"line":139,"path":"src/init.lua"}},{"name":"waitFor","desc":"This is a custom wrapper function for the `.WaitForChild` method. Use this utility function to simplify your code and avoid redundant chains of consequtive `.WaitForChild` calls.\\n\\n##### Usage example:\\n```lua\\t\\t\\n-- Long, consequtive calls of .WaitForChild...\\nA:WaitForChild(\'B\'):WaitForChild(\'C\'):WaitForChild(\'D\')\\n\\n-- ...can be simplied to this\\nsilk.waitFor{ A, \'B\', \'C\', \'D\' }\\n```","params":[{"name":"objects","desc":"","lua_type":"table"},{"name":"timeout","desc":"","lua_type":"number?"}],"returns":[{"desc":"","lua_type":"Instance\\r\\n"}],"function_type":"static","tags":["utility"],"yields":true,"source":{"line":177,"path":"src/init.lua"}},{"name":"FireAllClients","desc":"","params":[{"name":"action","desc":"","lua_type":"string"},{"name":"...","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"nil\\r\\n"}],"function_type":"method","tags":["network"],"source":{"line":192,"path":"src/init.lua"}},{"name":"FireClient","desc":"","params":[{"name":"client","desc":"","lua_type":"Player"},{"name":"action","desc":"","lua_type":"string"},{"name":"...","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"nil\\r\\n"}],"function_type":"method","tags":["network"],"source":{"line":200,"path":"src/init.lua"}},{"name":"FireServer","desc":"","params":[{"name":"action","desc":"","lua_type":"string"},{"name":"...","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"nil\\r\\n"}],"function_type":"method","tags":["network"],"source":{"line":208,"path":"src/init.lua"}},{"name":"InvokeServer","desc":"","params":[{"name":"action","desc":"","lua_type":"string"},{"name":"...","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"...any\\r\\n"}],"function_type":"method","tags":["network"],"source":{"line":216,"path":"src/init.lua"}},{"name":"RegisterAction","desc":"Register an action to the server to quickly handle commuincation between server and client.\\n\\n:::tip\\nUse this method in packages that require server and client communication for initialization.\\n:::","params":[{"name":"action","desc":"","lua_type":"string"},{"name":"callback","desc":"","lua_type":"((...any) -> ...any)"}],"returns":[{"desc":"","lua_type":"nil\\r\\n"}],"function_type":"method","tags":["network"],"source":{"line":230,"path":"src/init.lua"}},{"name":"UnregisterAction","desc":"Remove an existing action from the server.","params":[{"name":"action","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"nil\\r\\n"}],"function_type":"method","tags":["network"],"source":{"line":239,"path":"src/init.lua"}},{"name":"AppendClasses","desc":"Use this method to supply class directories to the framework.","params":[{"name":"classesDirectories","desc":"","lua_type":"table"}],"returns":[{"desc":"","lua_type":"nil\\r\\n"}],"function_type":"method","tags":["initializer"],"source":{"line":248,"path":"src/init.lua"}},{"name":"AppendContainers","desc":"Use this method to supply container directories to the framework.","params":[{"name":"containerDirectories","desc":"","lua_type":"table"}],"returns":[{"desc":"","lua_type":"nil\\r\\n"}],"function_type":"method","tags":["initializer"],"source":{"line":276,"path":"src/init.lua"}},{"name":"AppendPackages","desc":"Use this method to supply multiple package directories to the framework.","params":[{"name":"packageDirectories","desc":"","lua_type":"table"}],"returns":[{"desc":"","lua_type":"nil\\r\\n"}],"function_type":"method","tags":["initializer"],"source":{"line":295,"path":"src/init.lua"}},{"name":"Declare","desc":"Used internally to indicate potential any errors and warnings to output.","params":[{"name":"callback","desc":"","lua_type":"((msg: string) -> any)"},{"name":"msg","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"nil\\r\\n"}],"function_type":"method","source":{"line":321,"path":"src/init.lua"}},{"name":"GetContainer","desc":"Returns the container Instance for `container`.","params":[{"name":"container","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"Instance\\r\\n"}],"function_type":"method","source":{"line":329,"path":"src/init.lua"}},{"name":"GetService","desc":"Gets a Roblox service as an [Instance] and caches it internally. This method is called internally whenever a service is attempted to be retrieved via `silk.<Service>`.","params":[{"name":"service","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"Instance\\r\\n"}],"function_type":"method","source":{"line":337,"path":"src/init.lua"}},{"name":"InitClass","desc":"This method is called internally whenever a class is referenced `silk.Classes.<Class>`. This method can be used directly to intialize any class if needed.","params":[{"name":"class","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"any\\r\\n"}],"function_type":"method","source":{"line":348,"path":"src/init.lua"}},{"name":"InitPackage","desc":"This method is called internally whenever a package is referenced `silk.Packages.<Package>`.\\n\\n:::tip\\nUse this method to intialize any singleton packages during the initializer phase.\\n:::","params":[{"name":"package","desc":"","lua_type":"Package"}],"returns":[{"desc":"","lua_type":"any\\r\\n"}],"function_type":"method","source":{"line":374,"path":"src/init.lua"}},{"name":"IsServer","desc":"Returns `true` if the current execution is taking place on the server.","params":[],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"method","source":{"line":408,"path":"src/init.lua"}},{"name":"Wait","desc":"Yields until the initialization phase is completed, i.e. [Silk] should be accessed this way for all scripts except the initializer scripts. See [Silk.Weave] for more information.","params":[],"returns":[{"desc":"","lua_type":"Silk\\r\\n"}],"function_type":"method","yields":true,"source":{"line":417,"path":"src/init.lua"}},{"name":"Weave","desc":"Marks the end of the initialization phase and resumes execution for all scripts yielding with [Silk.Wait]. Use this method inside of a single initializer script and call it at the end of the phase when all the initializations are complete. See below for more details.\\n\\n##### Sample initializer script\\n```lua\\n-- || initializer.server.lua ||\\n\\nlocal silk = require(...)\\n\\n-- Perform initializations\\nsilk:AppendPackages{ ... }\\nsilk:AppendContainers{ ... }\\nsilk:AppendClasses{ ... }\\nsilk.Packages.Network:AppendCommunicators{ ... }\\n\\n-- Finally, call Silk.Weave to mark the end of the initialization phase\\nsilk:Weave()\\n```","params":[],"returns":[{"desc":"","lua_type":"nil\\r\\n"}],"function_type":"method","source":{"line":446,"path":"src/init.lua"}}],"properties":[],"types":[{"name":"Container","desc":"A container is any [Instance] (usually a [Folder]) that contains a specific collection of objects as its children. Containers can be added to the framework using [Silk.AppendContainers] during the initializer phase.\\n\\n##### Adding containers:\\n```lua\\n-- || initializer.server.lua ||\\n\\nsilk:AppendContainers{\\n\\n\\t-- Supply a folder \'Assets\' as a container with the name \'Asset\'\\n\\tAsset = silk.ReplicatedStorage:WaitForChild(\'Assets\'),\\n}\\n```\\n\\nYou can access a container by executing `Silk.Get<ContainerName>(object: Instance) -> nil` as a method of the framework. See below for more details.\\n\\n##### Accessing objects inside containers:\\n```lua\\n-- A container named \'Asset\'\\nlocal asset = silk:GetAsset(\'Model\'):Clone()\\n```\\n\\nOther container methods:\\n- [Silk.AppendContainers]\\n- [Silk.GetContainer]","lua_type":"Instance","source":{"line":489,"path":"src/init.lua"}},{"name":"Service","desc":"Roblox service as an [Instance].\\n\\n##### Getting a service:\\n```lua\\n-- Directly access any service from Silk\\nlocal replicatedStorage = silk.ReplicatedStorage\\n```\\n\\n:::caution Limitation\\nYou may recieve an error while trying to get some services. This is because the service may not exist in the current list of services. To fix this, open the [ModuleScript] `services` and manually type it in.\\n:::","lua_type":"Instance","source":{"line":506,"path":"src/init.lua"}}],"name":"Silk","desc":"A singleton class that is shared between all scripts.","source":{"line":9,"path":"src/init.lua"}}')}}]);