[{"title":"Installing SILK","type":0,"sectionRef":"#","url":"/silk/docs/getting_started/installation","content":"Installing SILK Head over to GitHub Releases and download the attached .rbxm file from the latest release. Alternatively, download the source code and move the src folder inside your project and rename it to &quot;silk&quot;.","keywords":""},{"title":"Client","type":0,"sectionRef":"#","url":"/silk/api/Client","content":"On this page Client","keywords":""},{"title":"The SILK Lifecycle","type":0,"sectionRef":"#","url":"/silk/docs/lifecycle","content":"The SILK Lifecycle The initialization phase is initiated by a bootstrapper script which performs the necessary functions to provide packages, containers, etc. to the framework. During the uninitialized phase, any script that attempts to access the primary class singleton using Silk.Wait will yield until the initialization script completes execution. It's important to note that the server initialization phase takes precedence over the client initialization phase. If the client requests initialization data before the server reaches the initialized state, the client will yield until the server is ready to send data back. Configuration will only have to be supplied to the server by the developer and not twice over—to the client as well. The client essentially makes a local copy of the initialized singleton class using data returned by the server. Just like with normal server-sided scripts, client scripts begin execution immediately after the client reaches the initialized state. Additionally, all communication between client and server, including during the client initialization phase, occurs within the server intialized state. This approach gurantees that the server is always in a ready, initialized state during all communication. The framework lifecycle is designed to simplify the control of package usage and stage execution for developers. Diagram of the SILK lifecycle:​","keywords":""},{"title":"About","type":0,"sectionRef":"#","url":"/silk/docs/intro","content":"About SILK is a Roblox game framework that aims to simplify the game development process. The simple stage-execution model of SILK enables developers to manage stage execution in an organized manner. Moreover, SILK is highly adaptable to any type of development workflow and preferences. It also introduces Packages, which provide a structured way to manage codebase and its functionality. With packages, developers are able to maintain and develop code in a non-destrive manner, making the execution far more reliable and predictable. Pre-written packages that provide core functionality are also included by default in the framework. Get started by following steps to the Installation or check out some other links below... API DocumentationThe SILK Lifecycle","keywords":""},{"title":"The Initialization Phase","type":0,"sectionRef":"#","url":"/silk/docs/getting_started/initialization","content":"","keywords":""},{"title":"Project Structure​","type":1,"pageTitle":"The Initialization Phase","url":"/silk/docs/getting_started/initialization#project-structure","content":"While a SILK project can be structured in any way, the following project structure provides an idea of a typical, minimalistic approach. Ideal project structure:​ Project │ ├─ ServerScriptService │ ├─ initializer.server.lua │ └─ server.lua │ ├─ ReplicatedStorage │ └─ silk │ └─ ... │ └─ StarterPlayer └─ StarterPlayerScripts ├─ initializer.client.lua └─ client.lua   "},{"title":"Initializer Scripts​","type":1,"pageTitle":"The Initialization Phase","url":"/silk/docs/getting_started/initialization#initializer-scripts","content":"To begin, start by creating a single initializer script on the server. This script will be responsible for making sure the neccessary dependancy packages, containers, etc. are included in the framework in order for all the other scripts to begin execution. "},{"title":"Package","type":0,"sectionRef":"#","url":"/silk/api/Package","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Package","url":"/silk/api/Package#properties","content":" "},{"title":"__singleton​","type":1,"pageTitle":"Package","url":"/silk/api/Package#__singleton","content":"&lt;/&gt; Package.__singleton: boolean An optional meta attribute that can be included in any package. If set to true, a cached reference to the package is returned whenever the package is referenced. info If Package.__initialize is also provided, the return value recieved after calling this method is cached instead. "},{"title":"Functions​","type":1,"pageTitle":"Package","url":"/silk/api/Package#functions","content":" "},{"title":"__initialize​","type":1,"pageTitle":"Package","url":"/silk/api/Package#__initialize","content":"&lt;/&gt; Package.__initialize(silk: Silk) → any An optional meta function that can be included in any package. The typical usecase for this is when silk is needed to perform futher intiailizations inside the package and to provide a simple, non-desrutive way for the package to access the main class. yielding Package.__initialize should be treated like a normal metamethod. Therefore, any thread yielding functions inside of the method will result in an error. "},{"title":"Silk","type":0,"sectionRef":"#","url":"/silk/api/Silk","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#types","content":" "},{"title":"Container​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#Container","content":"&lt;/&gt; type Container = Instance  A container is any Instance (usually a Folder) that contains a specific collection of objects as its children. Containers can be added to the framework using Silk.AppendContainers during the initializer phase. Adding containers: -- || initializer.server.lua || silk:AppendContainers{ -- Supply a folder 'Assets' as a container with the name 'Asset' Asset = silk.ReplicatedStorage:WaitForChild('Assets'), } You can access a container by executing Silk.Get&lt;ContainerName&gt;(object: Instance) -&gt; nil as a method of the framework. See below for more details. Accessing objects inside containers: -- A container named 'Asset' local asset = silk:GetAsset('Model'):Clone() Other container methods: Silk.AppendContainers Silk.GetContainer  "},{"title":"Service​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#Service","content":"&lt;/&gt; type Service = Instance  Roblox service as an Instance. Getting a service: -- Directly access any service from Silk local replicatedStorage = silk.ReplicatedStorage Limitation You may recieve an error while trying to get some services. This is because the service may not exist in the current list of services. To fix this, open the ModuleScript services and manually type it in. "},{"title":"Functions​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#functions","content":" "},{"title":"getScript​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#getScript","content":"utility &lt;/&gt; Silk.getScript() → ModuleScript  This utility function returns a reference to the main SILK ModuleScript. You can use it to easily access the contents of the script. For instance, when adding in essential packages to the framework. Adding essential packages: -- || initializer.server.lua || silk:AppendPackages{ -- Directly access children of the Silk script silk.getScript():WaitForChild('essentials'), }   "},{"title":"new​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#new","content":"utility &lt;/&gt; Silk.new( object: string | Instance , parent: Instance? ) → self Built-in implementation of a method-chainable object instantiator. Call itself at the end of the chain to return Instance. important Do not forget to call itself after instantiation to return Instance (if needed). Creating a new object: local part = silk.new('Part', workspace) .Name('NewPart') .Anchored(true)()   "},{"title":"waitFor​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#waitFor","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields utility &lt;/&gt; Silk.waitFor( objects: table, timeout: number? ) → Instance  This is a custom wrapper function for the .WaitForChild method. Use this utility function to simplify your code and avoid redundant chains of consequtive .WaitForChild calls. Usage example: -- Long, consequtive calls of .WaitForChild... A:WaitForChild('B'):WaitForChild('C'):WaitForChild('D') -- ...can be simplied to this silk.waitFor{ A, 'B', 'C', 'D' }   "},{"title":"FireAllClients​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#FireAllClients","content":"network &lt;/&gt; Silk:FireAllClients( action: string, ...: any ) → nil   "},{"title":"FireClient​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#FireClient","content":"network &lt;/&gt; Silk:FireClient( client: Player , action: string, ...: any ) → nil   "},{"title":"FireServer​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#FireServer","content":"network &lt;/&gt; Silk:FireServer( action: string, ...: any ) → nil   "},{"title":"InvokeServer​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#InvokeServer","content":"network &lt;/&gt; Silk:InvokeServer( action: string, ...: any ) → ...any   "},{"title":"RegisterAction​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#RegisterAction","content":"network &lt;/&gt; Silk:RegisterAction( action: string, callback: ((...any) → ...any) ) → nil Register an action to the server to quickly handle commuincation between server and client. tip Use this method in packages that require server and client communication for initialization.  "},{"title":"UnregisterAction​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#UnregisterAction","content":"network &lt;/&gt; Silk:UnregisterAction(action: string) → nil Remove an existing action from the server.  "},{"title":"AppendClasses​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#AppendClasses","content":"initializer &lt;/&gt; Silk:AppendClasses(classesDirectories: table) → nil Use this method to supply class directories to the framework.  "},{"title":"AppendContainers​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#AppendContainers","content":"initializer &lt;/&gt; Silk:AppendContainers(containerDirectories: table) → nil Use this method to supply container directories to the framework.  "},{"title":"AppendPackages​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#AppendPackages","content":"initializer &lt;/&gt; Silk:AppendPackages(packageDirectories: table) → nil Use this method to supply multiple package directories to the framework.  "},{"title":"Declare​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#Declare","content":"&lt;/&gt; Silk:Declare( callback: ((msg: string) → any), msg: string ) → nil Used internally to indicate potential any errors and warnings to output.  "},{"title":"GetContainer​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#GetContainer","content":"&lt;/&gt; Silk:GetContainer(container: string) → Instance  Returns the container Instance for container.  "},{"title":"GetService​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#GetService","content":"&lt;/&gt; Silk:GetService(service: string) → Instance  Gets a Roblox service as an Instance and caches it internally. This method is called internally whenever a service is attempted to be retrieved via silk.&lt;Service&gt;.  "},{"title":"InitClass​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#InitClass","content":"&lt;/&gt; Silk:InitClass(class: string) → any This method is called internally whenever a class is referenced silk.Classes.&lt;Class&gt;. This method can be used directly to intialize any class if needed.  "},{"title":"InitPackage​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#InitPackage","content":"&lt;/&gt; Silk:InitPackage(package: Package) → any This method is called internally whenever a package is referenced silk.Packages.&lt;Package&gt;. tip Use this method to intialize any singleton packages during the initializer phase.  "},{"title":"IsServer​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#IsServer","content":"&lt;/&gt; Silk:IsServer() → boolean Returns true if the current execution is taking place on the server.  "},{"title":"Wait​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Silk:Wait() → Silk Yields until the initialization phase is completed, i.e. Silk should be accessed this way for all scripts except the initializer scripts. See Silk.Weave for more information.  "},{"title":"Weave​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#Weave","content":"&lt;/&gt; Silk:Weave() → nil Marks the end of the initialization phase and resumes execution for all scripts yielding with Silk.Wait. Use this method inside of a single initializer script and call it at the end of the phase when all the initializations are complete. See below for more details. Sample initializer script -- || initializer.server.lua || local silk = require(...) -- Perform initializations silk:AppendPackages{ ... } silk:AppendContainers{ ... } silk:AppendClasses{ ... } silk.Packages.Network:AppendCommunicators{ ... } -- Finally, call Silk.Weave to mark the end of the initialization phase silk:Weave()  "}]