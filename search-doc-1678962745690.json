[{"title":"Client","type":0,"sectionRef":"#","url":"/silk/api/Client","content":"On this page Client","keywords":""},{"title":"Initialization Phase","type":0,"sectionRef":"#","url":"/silk/docs/getting_started/initialization_phase","content":"","keywords":""},{"title":"Initializer Script​","type":1,"pageTitle":"Initialization Phase","url":"/silk/docs/getting_started/initialization_phase#initializer-script","content":"To begin, start by creating a single initializer script on the server. This script will be responsible for making sure the neccessary dependancy packages, containers, etc. are included in the framework in order for all the other scripts to begin execution. "},{"title":"About","type":0,"sectionRef":"#","url":"/silk/docs/intro","content":"About SILK is an intricate game development framework designed to streamline the overall process of game development. The SILK lifecyle, with its simple yet effective stage-execution model, enables developers to effectively manage large pieces of code with ease, keeping everything well-organized. This framework is highly versatile and flexible—adaptable to all types of different development workflows and preferences. With the introduction of packages, developers are given the ability of developing code in a non-destructive manner, quickly producing more reliable and predictable results. The framework also includes pre-written packages involving the common core functionalities for any typical project. Get started with SILK by visiting Getting Started or check out the other links below. API DocumentationThe SILK Lifecycle","keywords":""},{"title":"Setting Up","type":0,"sectionRef":"#","url":"/silk/docs/getting_started/setting_up","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Setting Up","url":"/silk/docs/getting_started/setting_up#installation","content":"Go to GitHub Releases and download the attached .rbxm file from the latest release. Alternatively, download the source code and move the src folder to anywhere inside your project then rename it to silk.  "},{"title":"Project Structure​","type":1,"pageTitle":"Setting Up","url":"/silk/docs/getting_started/setting_up#project-structure","content":"A project can typically be structured in any way preferred by the developer. The following structure shows a minimalistic example of what an ideal project structure might look like. Ideal project structure:​ Project │ ├─ ServerScriptService │ ├─ initializer.server.lua │ └─ script.server.lua │ ├─ ReplicatedStorage │ └─ silk │ └─ ... │ └─ StarterPlayer └─ StarterPlayerScripts ├─ initializer.client.lua └─ script.client.lua  "},{"title":"The SILK Lifecycle","type":0,"sectionRef":"#","url":"/silk/docs/lifecycle","content":"The SILK Lifecycle The SILK lifecycle is designed to simplify the overall control of package usage and stage execution. The initialization phase is initiated by a single bootstrapper script that is responsible for supplying the framework with any specific dependencies. Any script that attempts to retrieve and access the primary singleton class using Silk.Wait during the uninitialized phase will yield until the initialization is completed. The server initialization phase takes precedence over the client initialization phase, i.e. if the client requests initialization data before the server reaches the initialized state, the client must yield until the server is ready to provide the data. Configuration will only be provided once through the server intializer script. When the client requests data for initialization, it aims to make a seamless local copy of the initialized singleton class that exists on the server. In this way, when the data is recieved by the client, some information may be lost since it may not be visible to the client. Just like with normal server-sided scripts, client scripts begin execution immediately after the client reaches the initialized state. Additionally, any communication between the client and server, including during the client initialization phase, only takes place with the server in its intialized state. This approach gurantees that the server is always in a ready state whenever the client communicates. Diagram of the SILK lifecycle:​","keywords":""},{"title":"Package","type":0,"sectionRef":"#","url":"/silk/api/Package","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Package","url":"/silk/api/Package#properties","content":" "},{"title":"__singleton​","type":1,"pageTitle":"Package","url":"/silk/api/Package#__singleton","content":"&lt;/&gt; Package.__singleton: boolean An optional meta attribute that can be included in any package. If set to true, a cached reference to the package is returned whenever the package is referenced. info If Package.__initialize is also provided, the return value recieved after calling this method is cached instead. "},{"title":"Functions​","type":1,"pageTitle":"Package","url":"/silk/api/Package#functions","content":" "},{"title":"__initialize​","type":1,"pageTitle":"Package","url":"/silk/api/Package#__initialize","content":"&lt;/&gt; Package.__initialize(silk: Silk) → any An optional meta function that can be included in any package. The typical usecase for this is when silk is needed to perform futher intiailizations inside the package and to provide a simple, non-desrutive way for the package to access the main class. yielding Package.__initialize should be treated like a normal metamethod. Therefore, any thread yielding functions inside of the method will result in an error. "},{"title":"Silk","type":0,"sectionRef":"#","url":"/silk/api/Silk","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#types","content":" "},{"title":"Container​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#Container","content":"&lt;/&gt; type Container = Instance  A container is any Instance (usually a Folder) that contains a specific collection of objects as its children. Containers can be added to the framework using Silk.AppendContainers during the initializer phase. Adding containers: -- || initializer.server.lua || silk:AppendContainers{ -- Supply a folder 'Assets' as a container with the name 'Asset' Asset = silk.ReplicatedStorage:WaitForChild('Assets'), } You can access a container by executing Silk.Get&lt;ContainerName&gt;(object: Instance) -&gt; nil as a method of the framework. See below for more details. Accessing objects inside containers: -- A container named 'Asset' local asset = silk:GetAsset('Model'):Clone() Other container methods: Silk.AppendContainers Silk.GetContainer  "},{"title":"Service​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#Service","content":"&lt;/&gt; type Service = Instance  Roblox service as an Instance. Getting a service: -- Directly access any service from Silk local replicatedStorage = silk.ReplicatedStorage Limitation You may recieve an error while trying to get some services. This is because the service may not exist in the current list of services. To fix this, open the ModuleScript services and manually type it in. "},{"title":"Functions​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#functions","content":" "},{"title":"getScript​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#getScript","content":"utility &lt;/&gt; Silk.getScript() → ModuleScript  This utility function returns a reference to the main SILK ModuleScript. You can use it to easily access the contents of the script. For instance, when adding in essential packages to the framework. Adding essential packages: -- || initializer.server.lua || silk:AppendPackages{ -- Directly access children of the Silk script silk.getScript():WaitForChild('essentials'), }   "},{"title":"new​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#new","content":"utility &lt;/&gt; Silk.new( object: string | Instance , parent: Instance? ) → self Built-in implementation of a method-chainable object instantiator. Call itself at the end of the chain to return Instance. important Do not forget to call itself after instantiation to return Instance (if needed). Creating a new object: local part = silk.new('Part', workspace) .Name('NewPart') .Anchored(true)()   "},{"title":"waitFor​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#waitFor","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields utility &lt;/&gt; Silk.waitFor( objects: table, timeout: number? ) → Instance  This is a custom wrapper function for the .WaitForChild method. Use this utility function to simplify your code and avoid redundant chains of consequtive .WaitForChild calls. Usage example: -- Long, consequtive calls of .WaitForChild... A:WaitForChild('B'):WaitForChild('C'):WaitForChild('D') -- ...can be simplied to this silk.waitFor{ A, 'B', 'C', 'D' }   "},{"title":"FireAllClients​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#FireAllClients","content":"network &lt;/&gt; Silk:FireAllClients( action: string, ...: any ) → nil   "},{"title":"FireClient​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#FireClient","content":"network &lt;/&gt; Silk:FireClient( client: Player , action: string, ...: any ) → nil   "},{"title":"FireServer​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#FireServer","content":"network &lt;/&gt; Silk:FireServer( action: string, ...: any ) → nil   "},{"title":"InvokeServer​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#InvokeServer","content":"network &lt;/&gt; Silk:InvokeServer( action: string, ...: any ) → ...any   "},{"title":"RegisterAction​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#RegisterAction","content":"network &lt;/&gt; Silk:RegisterAction( action: string, callback: ((...any) → ...any) ) → nil Register an action to the server to quickly handle commuincation between server and client. tip Use this method in packages that require server and client communication for initialization.  "},{"title":"UnregisterAction​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#UnregisterAction","content":"network &lt;/&gt; Silk:UnregisterAction(action: string) → nil Remove an existing action from the server.  "},{"title":"AppendClasses​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#AppendClasses","content":"initializer &lt;/&gt; Silk:AppendClasses(classesDirectories: table) → nil Use this method to supply class directories to the framework.  "},{"title":"AppendContainers​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#AppendContainers","content":"initializer &lt;/&gt; Silk:AppendContainers(containerDirectories: table) → nil Use this method to supply container directories to the framework.  "},{"title":"AppendPackages​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#AppendPackages","content":"initializer &lt;/&gt; Silk:AppendPackages(packageDirectories: table) → nil Use this method to supply multiple package directories to the framework.  "},{"title":"Declare​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#Declare","content":"&lt;/&gt; Silk:Declare( callback: ((msg: string) → any), msg: string ) → nil Used internally to indicate potential any errors and warnings to output.  "},{"title":"GetContainer​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#GetContainer","content":"&lt;/&gt; Silk:GetContainer(container: string) → Instance  Returns the container Instance for container.  "},{"title":"GetService​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#GetService","content":"&lt;/&gt; Silk:GetService(service: string) → Instance  Gets a Roblox service as an Instance and caches it internally. This method is called internally whenever a service is attempted to be retrieved via silk.&lt;Service&gt;.  "},{"title":"InitClass​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#InitClass","content":"&lt;/&gt; Silk:InitClass(class: string) → any This method is called internally whenever a class is referenced silk.Classes.&lt;Class&gt;. This method can be used directly to intialize any class if needed.  "},{"title":"InitPackage​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#InitPackage","content":"&lt;/&gt; Silk:InitPackage(package: Package) → any This method is called internally whenever a package is referenced silk.Packages.&lt;Package&gt;. tip Use this method to intialize any singleton packages during the initializer phase.  "},{"title":"IsServer​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#IsServer","content":"&lt;/&gt; Silk:IsServer() → boolean Returns true if the current execution is taking place on the server.  "},{"title":"Wait​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Silk:Wait() → Silk Yields until the initialization phase is completed, i.e. Silk should be accessed this way for all scripts except the initializer scripts. See Silk.Weave for more information.  "},{"title":"Weave​","type":1,"pageTitle":"Silk","url":"/silk/api/Silk#Weave","content":"&lt;/&gt; Silk:Weave() → nil Marks the end of the initialization phase and resumes execution for all scripts yielding with Silk.Wait. Use this method inside of a single initializer script and call it at the end of the phase when all the initializations are complete. See below for more details. Sample initializer script -- || initializer.server.lua || local silk = require(...) -- Perform initializations silk:AppendPackages{ ... } silk:AppendContainers{ ... } silk:AppendClasses{ ... } silk.Packages.Network:AppendCommunicators{ ... } -- Finally, call Silk.Weave to mark the end of the initialization phase silk:Weave()  "}]